<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>แอปวัดพื้นที่และความสูง</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            max-width: 640px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px 0;
            animation: fadeInUp 0.6s ease-out;
        }
        
        .header h1 {
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            opacity: 0.9;
            font-size: 14px;
        }
        
        .camera-container {
            position: relative;
            width: 100%;
            /* ใช้สัดส่วนภาพแทนกำหนดความสูงตายตัว เพื่อให้ responsive */
            aspect-ratio: 16 / 9;
            background: rgba(0,0,0,0.8);
            border-radius: 15px;
            margin-bottom: 20px;
            overflow: hidden;
            border: 3px solid rgba(255,255,255,0.2);
            animation: fadeInScale 0.8s ease-out 0.1s both;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }
        
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 2px solid #00ff88;
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
        }
        
        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #00ff88;
            box-shadow: 0 0 10px rgba(0,255,136,0.8);
        }
        
        .crosshair::before {
            top: 50%;
            left: -10px;
            right: -10px;
            height: 2px;
            transform: translateY(-50%);
        }
        
        .crosshair::after {
            left: 50%;
            top: -10px;
            bottom: -10px;
            width: 2px;
            transform: translateX(-50%);
        }
        
        .measurement-points {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        .point {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #ff4757;
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(255,71,87,0.8);
            animation: pulse 2s infinite, bounceIn 0.5s ease-out;
        }
        
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }
        
        .measurement-line {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, #ff4757, #00ff88);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
            transform-origin: left center;
            animation: drawLine 0.8s ease-out, lineGlow 3s ease-in-out infinite 0.8s;
        }
        
        @keyframes drawLine {
            from {
                width: 0;
            }
            to {
                width: 100%;
            }
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
            align-items: center;
            animation: fadeInUp 0.6s ease-out 0.3s both;
        }

        .input, select {
            padding: 15px 18px;
            border-radius: 15px;
            border: none;
            background: rgba(255,255,255,0.15);
            color: white;
            outline: none;
            width: 100%;
            font-size: 16px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .input:focus, select:focus {
            background: rgba(255,255,255,0.25);
            border: 1px solid rgba(0,255,136,0.5);
            box-shadow: 0 0 20px rgba(0,255,136,0.3);
            transform: translateY(-2px);
        }

        .input::placeholder {
            color: rgba(255,255,255,0.6);
        }
        
        select option { 
            color: #111; 
            background: #fff;
            padding: 10px;
        }
        
        .btn {
            padding: 16px 24px;
            border: none;
            border-radius: 15px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #00ff88, #00d4aa);
            color: white;
            box-shadow: 0 8px 25px rgba(0,255,136,0.4);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #00d4aa, #00ff88);
            box-shadow: 0 12px 35px rgba(0,255,136,0.6);
            transform: translateY(-3px);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #ff4757, #ff3742);
            color: white;
            box-shadow: 0 8px 25px rgba(255,71,87,0.4);
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #ff3742, #ff4757);
            box-shadow: 0 12px 35px rgba(255,71,87,0.6);
            transform: translateY(-3px);
        }
        
        .btn-info {
            background: linear-gradient(135deg, #3742fa, #2f3542);
            color: white;
            box-shadow: 0 8px 25px rgba(55,66,250,0.4);
        }

        .btn-info:hover {
            background: linear-gradient(135deg, #2f3542, #3742fa);
            box-shadow: 0 12px 35px rgba(55,66,250,0.6);
            transform: translateY(-3px);
        }
        
        .btn:active {
            transform: translateY(-1px);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }
        
        .mode-selector {
            display: flex;
            background: rgba(255,255,255,0.15);
            border-radius: 20px;
            padding: 8px;
            margin-bottom: 25px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            animation: fadeInUp 0.6s ease-out 0.2s both;
        }
        
        .mode-btn {
            flex: 1;
            padding: 15px 20px;
            border: none;
            background: transparent;
            color: white;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 600;
            font-size: 14px;
            position: relative;
            overflow: hidden;
        }

        .mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .mode-btn:hover::before {
            opacity: 1;
        }
        
        .mode-btn.active {
            background: linear-gradient(135deg, rgba(255,255,255,0.25), rgba(255,255,255,0.15));
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transform: translateY(-1px);
        }

        .mode-btn.active::before {
            opacity: 0;
        }
        
        .results {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            animation: fadeInUp 0.6s ease-out 0.4s both;
        }
        
        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .result-item:last-child {
            border-bottom: none;
        }
        
        .result-label {
            font-weight: 500;
            opacity: 0.9;
        }
        
        .result-value {
            font-size: 18px;
            font-weight: 700;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0,255,136,0.3);
        }
        
        .instructions {
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border-left: 4px solid #00ff88;
            animation: fadeInUp 0.6s ease-out 0.5s both;
        }
        
        .instructions h3 {
            margin-bottom: 10px;
            color: #00ff88;
        }
        
        .instructions ul {
            list-style: none;
            padding-left: 0;
        }
        
        .instructions li {
            padding: 5px 0;
            opacity: 0.9;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .instructions li::before {
            content: "📱 ";
            margin-right: 8px;
        }

        .instructions li:hover {
            transform: translateX(5px);
            color: #00ff88;
        }

        /* Math formulas section */
        .math-formulas {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            border-left: 4px solid #ff6b6b;
            animation: fadeInUp 0.6s ease-out 0.6s both;
        }

        .math-formulas h3 {
            color: #ff6b6b;
            margin-bottom: 15px;
            text-align: center;
            font-size: 18px;
        }

        .formula-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .formula-item {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .formula-item:hover {
            transform: translateY(-3px) scale(1.02);
        }

        .formula-title {
            color: #ffd93d;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .formula-equation {
            font-family: 'Courier New', monospace;
            font-size: 16px;
            color: #6bcf7f;
            margin-bottom: 5px;
        }

        .formula-desc {
            font-size: 12px;
            opacity: 0.8;
            color: #e1e1e1;
        }

        /* Calculation steps display */
        .calculation-steps {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            border-left: 4px solid #6bcf7f;
            display: none;
        }

        .calculation-steps.show {
            display: block;
        }

        .calculation-steps h3 {
            color: #6bcf7f;
            margin-bottom: 15px;
            text-align: center;
        }

        .step-item {
            background: rgba(255,255,255,0.05);
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 3px solid #6bcf7f;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .step-item:hover {
            transform: translateY(-3px) scale(1.02);
        }

        .step-number {
            color: #ffd93d;
            font-weight: bold;
            margin-right: 8px;
        }

        .step-formula {
            font-family: 'Courier New', monospace;
            color: #6bcf7f;
            margin: 5px 0;
        }

        .step-result {
            color: #ff6b6b;
            font-weight: bold;
        }

        /* Angle indicator */
        .angle-indicator {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }

        .angle-arc {
            stroke: #ffd93d;
            stroke-width: 2;
            fill: none;
            opacity: 0.8;
        }

        .angle-label {
            fill: #ffd93d;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .camera-status {
            text-align: center;
            padding: 20px;
            color: #ff4757;
            font-weight: 500;
        }
        
        .measurement-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            backdrop-filter: blur(10px);
        }

        /* Ruler overlay */
        .ruler-overlay {
            position: absolute;
            left: 10px;
            bottom: 10px;
            background: rgba(0,0,0,0.6);
            color: #fff;
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 12px;
        }
        .ruler-label { opacity: 0.9; }
        .ruler-bar {
            height: 8px;
            margin-top: 6px;
            background: repeating-linear-gradient(90deg, #ffffff, #ffffff 1px, transparent 1px, transparent 10px);
            border: 1px solid #ffffff;
            border-radius: 3px;
            width: 120px; /* will be overridden by JS */
            position: relative;
        }
        .ruler-bar::after {
            content: '';
            position: absolute;
            right: -1px;
            top: -4px;
            bottom: -4px;
            width: 2px;
            background: #ffffff;
        }

        .tick {
            position: absolute;
            bottom: 100%;
            width: 1px;
            background: #fff;
        }
        .tick.minor { height: 6px; opacity: 0.8; }
        .tick.major { height: 10px; }
        .tick-label {
            position: absolute;
            bottom: calc(100% + 12px);
            transform: translateX(-50%);
            color: #fff;
            font-size: 11px;
            white-space: nowrap;
            text-shadow: 0 1px 2px rgba(0,0,0,0.6);
        }

        /* Small field label for inputs */
        .field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .field-label {
            font-size: 12px;
            opacity: 0.85;
        }
        /* Hide camera selector for simpler UX */
        #cameraSelect { display: none; }
        /* Hide green center crosshair */
        .crosshair { display: none; }
        
        @media (max-width: 480px) {
            .container {
                padding: 15px;
            }
            
            .camera-container {
                aspect-ratio: 3 / 4;
            }
            
            .controls {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* Modern UI Animations and Transitions */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes shimmer {
            0% {
                background-position: -200px 0;
            }
            100% {
                background-position: calc(200px + 100%) 0;
            }
        }

        @keyframes bounceIn {
            0% {
                opacity: 0;
                transform: scale(0.3);
            }
            50% {
                opacity: 1;
                transform: scale(1.05);
            }
            70% {
                transform: scale(0.9);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* Enhanced loading states */
        .loading {
            position: relative;
            overflow: hidden;
        }

        .loading::before {
            content: '';
            position: absolute;
            top: 0;
            left: -200px;
            width: 200px;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            animation: shimmer 2s infinite;
        }

        /* Staggered animations for cards */
        .header {
            animation: fadeInUp 0.6s ease-out;
        }

        .camera-container {
            animation: fadeInScale 0.8s ease-out 0.1s both;
        }

        .mode-selector {
            animation: fadeInUp 0.6s ease-out 0.2s both;
        }

        .controls {
            animation: fadeInUp 0.6s ease-out 0.3s both;
        }

        .results {
            animation: fadeInUp 0.6s ease-out 0.4s both;
        }

        .instructions {
            animation: fadeInUp 0.6s ease-out 0.5s both;
        }

        .math-formulas {
            animation: fadeInUp 0.6s ease-out 0.6s both;
        }

        /* Enhanced button interactions */
        .btn {
            position: relative;
            overflow: hidden;
        }

        .btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:active::after {
            width: 300px;
            height: 300px;
        }

        /* Enhanced focus states */
        .input:focus, .btn:focus, .mode-btn:focus {
            outline: 2px solid rgba(0,255,136,0.5);
            outline-offset: 2px;
        }

        /* Smooth transitions for all interactive elements */
        .result-item, .formula-item, .step-item, .instructions li {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* Enhanced hover effects */
        .formula-item:hover, .step-item:hover {
            transform: translateY(-3px) scale(1.02);
        }

        .instructions li:hover {
            transform: translateX(5px);
            color: #00ff88;
        }

        /* Point addition animation */
        .point {
            animation: bounceIn 0.5s ease-out;
        }

        /* Measurement line drawing animation */
        .measurement-line {
            animation: drawLine 0.8s ease-out, lineGlow 3s ease-in-out infinite 0.8s;
        }

        @keyframes drawLine {
            from {
                width: 0;
            }
            to {
                width: 100%;
            }
        }

        /* Enhanced card hover effects */
        .results:hover, .instructions:hover, .math-formulas:hover, .calculation-steps:hover {
            border-color: rgba(255,255,255,0.4);
        }

        /* Optimized spacing and layout */
        .container > * + * {
            margin-top: 0;
        }

        .field {
            margin-bottom: 15px;
        }

        .field:last-child {
            margin-bottom: 0;
        }

        .field-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: rgba(255,255,255,0.9);
            font-size: 14px;
        }

        /* Enhanced visual hierarchy */
        h2, h3 {
            margin-bottom: 1rem;
            font-weight: 700;
        }

        h2 {
            font-size: 1.5rem;
            color: #00ff88;
        }

        h3 {
            font-size: 1.25rem;
        }

        /* Better text readability */
        p, li, span {
            line-height: 1.6;
        }

        /* Enhanced status indicators */
        .status-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .status-success {
            background: rgba(0,255,136,0.2);
            color: #00ff88;
            border: 1px solid rgba(0,255,136,0.3);
        }

        .status-warning {
            background: rgba(255,215,61,0.2);
            color: #ffd93d;
            border: 1px solid rgba(255,215,61,0.3);
        }

        .status-error {
            background: rgba(255,71,87,0.2);
            color: #ff4757;
            border: 1px solid rgba(255,71,87,0.3);
        }

        /* Enhanced tooltips */
        [data-tooltip] {
            position: relative;
            cursor: help;
        }

        [data-tooltip]:hover::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 12px;
            background: rgba(0,0,0,0.9);
            color: white;
            border-radius: 8px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            animation: fadeInUp 0.3s ease-out;
        }

        [data-tooltip]:hover::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(100%);
            border: 5px solid transparent;
            border-top-color: rgba(0,0,0,0.9);
            z-index: 1000;
        }

        /* Enhanced scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
            transition: background 0.3s ease;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.5);
        }
        
        .control-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 10px;
            border-left: 4px solid #00ff88;
        }

        .control-section h3 {
            color: #00ff88;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
        }

        .btn-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
    </style>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#764ba2">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="วัดระยะ">

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📏 แอปวัดพื้นที่และความสูง</h1>
            <p>ใช้กล้องหลังเพื่อวัดความยาว พื้นที่ และความสูง</p>
        </div>
        
        <div class="mode-selector">
            <button class="mode-btn active" onclick="setMode('distance', this)">วัดความยาว</button>
            <button class="mode-btn" onclick="setMode('area', this)">วัดพื้นที่</button>
            <button class="mode-btn" onclick="setMode('height', this)">วัดความสูง</button>
            <button class="mode-btn" onclick="setMode('angle', this)">วัดมุม (ตรีโกณมิติ)</button>
        </div>
        
        <!-- Math Formulas Section -->
        <div class="math-formulas">
            <h3>🧮 สูตรฟังก์ชันตรีโกณมิติที่ใช้ในโปรเจค</h3>
            <div class="formula-grid">
                <div class="formula-item">
                    <div class="formula-title">ฟังก์ชัน Sine</div>
                    <div class="formula-equation">sin θ = ตรงข้าม / ด้านเอียง</div>
                    <div class="formula-desc">ใช้หาความสูงจากมุมและระยะ</div>
                </div>
                <div class="formula-item">
                    <div class="formula-title">ฟังก์ชัน Cosine</div>
                    <div class="formula-equation">cos θ = ประชิด / ด้านเอียง</div>
                    <div class="formula-desc">ใช้หาระยะแนวนอนจากมุม</div>
                </div>
                <div class="formula-item">
                    <div class="formula-title">ฟังก์ชัน Tangent</div>
                    <div class="formula-equation">tan θ = ตรงข้าม / ประชิด</div>
                    <div class="formula-desc">ใช้หามุมจากอัตราส่วนด้าน</div>
                </div>
                <div class="formula-item">
                    <div class="formula-title">ทฤษฎีบทพีทาโกรัส</div>
                    <div class="formula-equation">c² = a² + b²</div>
                    <div class="formula-desc">หาความยาวตรงจาก 2 จุด</div>
                </div>
            </div>
        </div>
        
        <div class="camera-container">
            <video id="video" autoplay playsinline webkit-playsinline></video>
            <div class="camera-overlay">
                <div class="crosshair"></div>
                <div class="measurement-points" id="points"></div>
                <div class="measurement-info" id="info">จุดที่วัด: 0</div>
                <div class="ruler-overlay" id="rulerOverlay">
                    <div class="ruler-label" id="rulerLabel">สเกล: 1 ม. ≈ 100 px</div>
                    <div class="ruler-bar" id="rulerBar"></div>
                </div>
            </div>
            <div class="camera-status" id="camera-status" style="display: none;">
                กำลังเปิดกล้อง...
            </div>
        </div>
        
        <div class="">
            <!-- Common Controls -->
            <div class="control-section">
                <h3>🔄 การควบคุมทั่วไป</h3>
                <div class="btn-group">
                    <button class="btn btn-info" onclick="calculate()">📊 คำนวณ</button>
                    <button class="btn" onclick="undoPoint()">↩️ ย้อนกลับจุด</button>
                    <button class="btn btn-secondary" onclick="clearPoints()">🗑️ ล้างจุด</button>
                    <button class="btn btn-info" onclick="toggleCamera()">📷 เปิด/ปิดกล้อง</button>
                </div>
            </div>
            
            <!-- Camera Controls -->
            <div class="control-section" id="cameraControls">
                <h3>🎥 การตั้งค่ากล้อง</h3>
                <div class="control-grid">
                    <!-- <div class="field">
                        <label for="cameraSelect" class="field-label">เลือกกล้อง</label>
                        <select id="cameraSelect" title="เลือกกล้อง" onchange="onCameraChange(this.value)"></select>
                    </div> -->
                    <div class="field">
                        <label for="cameraHeightInput" class="field-label">ความสูงกล้อง (เมตร)</label>
                        <input id="cameraHeightInput" type="number" class="input" min="0.5" max="3" step="0.1" value="1.5" onchange="updateCameraHeight(this.value)" placeholder="ความสูงกล้องจากพื้น">
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-info" id="refreshBtn" onclick="refreshCameras()" style="display:none">🔄 รีเฟรชกล้อง</button>
                        <button class="btn btn-info" onclick="resetPerspectiveSettings()">🔄 รีเซ็ตการตั้งค่า</button>
                    </div>
                </div>
            </div>
            
            <!-- Measurement Controls -->
            <div class="control-section" id="measurementControls" style="display: none;">
                <h3>📐 การตั้งค่าการวัด</h3>
                <div class="control-grid">
                    <div class="field">
                        <label for="scaleInput" class="field-label">สเกล (พิกเซลต่อ 1 เมตร)</label>
                        <input id="scaleInput" type="number" class="input" min="1" step="1" value="100" title="สเกล (พิกเซลต่อเมตร)" placeholder="เช่น 200 หมายถึง 200px = 1ม.">
                    </div>
                    <div class="btn-group">
                        <button class="btn" id="calibBtn" onclick="toggleCalibration()">🎯 คาลิเบรตสเกล</button>
                        <button class="btn btn-info" onclick="autoCalibrate()">🎯 คาลิเบรตอัตโนมัติ</button>
                    </div>
                </div>
            </div>
            
            <!-- Height Mode Controls (Law of Cosines Calculator) -->
            <div class="control-section" id="heightControls" style="display: none;">
                <h3>📐 เครื่องคิดเลข Law of Cosines</h3>
                <p style="font-size: 12px; color: #e1e1e1; margin: 5px 0 15px;">สูตร: c² = a² + b² - 2ab cos(C) เมื่อ c = ความสูง</p>
                <div class="control-grid">
                    <div class="field">
                        <label for="angleInput" class="field-label">มุม C (องศา)</label>
                        <input id="angleInput" type="number" class="input" min="0" max="180" step="0.1" value="90" placeholder="กรอกมุม C ในหน่วยองศา" onchange="calculateHeightFromLawOfCosines()">
                    </div>
                    <div class="field">
                        <label for="sideAInput" class="field-label">ด้าน a (เมตร)</label>
                        <input id="sideAInput" type="number" class="input" min="0.1" max="100" step="0.1" value="3.0" placeholder="กรอกความยาวด้าน a" onchange="calculateHeightFromLawOfCosines()">
                    </div>
                    <div class="field">
                        <label for="sideBInput" class="field-label">ด้าน b (เมตร)</label>
                        <input id="sideBInput" type="number" class="input" min="0.1" max="100" step="0.1" value="4.0" placeholder="กรอกความยาวด้าน b" onchange="calculateHeightFromLawOfCosines()">
                    </div>
                </div>
            </div>
        </div>
        
        <div class="instructions">
            <h3>วิธีใช้งาน:</h3>
            <ul id="instructionsList">
                <li><strong>โหมดระยะทาง:</strong> เลือกจุดเริ่มต้นและจุดสิ้นสุด กดปุ่ม "เพิ่มจุด" ที่จุดทั้งสอง แล้วกด "คำนวณ"</li>
                <li><strong>โหมดพื้นที่:</strong> เพิ่มจุดรอบๆ พื้นที่ที่ต้องการวัด (อย่างน้อย 3 จุด) แล้วกด "คำนวณ"</li>
                <li><strong>โหมดความสูง:</strong> กรอกค่ามุม C และความยาวด้าน a, b ในเครื่องคิดเลข Law of Cosines แล้วกด "คำนวณ"</li>
                <li><strong>โหมดมุม:</strong> เลือก 3 จุด (จุดแรกเป็นจุดยอดของมุม) แล้วกด "คำนวณ"</li>
            </ul>
        </div>
        
        <!-- Calculation Steps Display -->
        <div class="calculation-steps" id="calculationSteps">
            <h3>📊 ขั้นตอนการคำนวณด้วยฟังก์ชันตรีโกณมิติ</h3>
            <div id="stepsContent">
                <!-- Steps will be populated by JavaScript -->
            </div>
        </div>

        <div class="results">
            <div class="result-item">
                <span class="result-label">ระยะทาง:</span>
                <span class="result-value" id="distance">0 ม.</span>
            </div>
            <div class="result-item">
                <span class="result-label">พื้นที่:</span>
                <span class="result-value" id="area">0 ตร.ม.</span>
            </div>
            <div class="result-item">
                <span class="result-label">ความสูง:</span>
                <span class="result-value" id="height">0 ม.</span>
            </div>
            <div class="result-item">
                <span class="result-label">มุม:</span>
                <span class="result-value" id="angle">0°</span>
            </div>
            <div class="result-item">
                <span class="result-label">จำนวนจุด:</span>
                <span class="result-value" id="point-count">0</span>
            </div>
        </div>
    </div>

    <script>
        let currentMode = 'distance';
        let points = [];
        let video = document.getElementById('video');
        let stream = null;
        let cameraActive = false;
        let calibrationMode = false;
        let calibrationPoints = []; // [{x,y} x2]
        
        // ตัวแปรสำหรับ Advanced Perspective Correction (ปรับปรุงความแม่นยำ)
        let cameraFOV = {
            horizontal: 60, // ค่าเริ่มต้น จะถูกปรับอัตโนมัติ
            vertical: 45    // ค่าเริ่มต้น จะถูกปรับอัตโนมัติ
        };
        let cameraHeight = 1.5; // ความสูงกล้องจากพื้น (เมตร)
        let cameraTilt = 0; // มุมเอียงกล้อง (องศา)
        let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 }; // การหมุนอุปกรณ์
        let manualDistanceMode = false; // โหมดกำหนดระยะทางเอง
        let manualDistance = 5.0; // ระยะทางที่ผู้ใช้กำหนดเอง (เมตร)
        
        // ข้อมูลอุปกรณ์สำหรับการปรับ FOV
        let deviceInfo = {
            type: 'unknown',
            brand: 'unknown',
            model: 'unknown',
            isTablet: false,
            screenSize: 'medium'
        };
        
        // โหมดตั้งฉากกับพื้น
        let perpendicularMode = true; // เปิดโดยค่าเริ่มต้น
        let targetTilt = 0; // มุมเป้าหมายสำหรับโหมดตั้งฉาก
        
        // เริ่มต้นระบบตรวจจับการหมุนอุปกรณ์
        function initDeviceOrientation() {
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', function(event) {
                    deviceOrientation.alpha = event.alpha || 0; // Z-axis (compass)
                    deviceOrientation.beta = event.beta || 0;   // X-axis (front-back tilt)
                    deviceOrientation.gamma = event.gamma || 0; // Y-axis (left-right tilt)
                    
                    // อัปเดตมุมเอียงกล้องจากการหมุนอุปกรณ์
                    cameraTilt = deviceOrientation.beta;
                    
                    // อัปเดต UI แสดงมุมเอียง
                    updateOrientationDisplay();
                    
                    // อัปเดตการแสดงผลทุก 1 วินาที
                    setInterval(() => {
                        if (cameraActive) {
                            calibrateCameraHeight(); // อัปเดตความสูงกล้องตามการเอียง
                            updateOrientationDisplay();
                            updateCameraHeightInput();
                        }
                    }, 1000);
                });
            }
        }
        
        // ฟังก์ชันสำหรับอัปเดตค่าความสูงกล้อง
        function updateCameraHeight(value) {
            cameraHeight = parseFloat(value) || 1.5;
        }
        
        // อัปเดต input ความสูงกล้องตามการคำนวณอัตโนมัติ
        function updateCameraHeightInput() {
            const input = document.getElementById('cameraHeightInput');
            if (input && Math.abs(parseFloat(input.value) - cameraHeight) > 0.1) {
                input.value = cameraHeight.toFixed(1);
            }
        }
        
        // รีเซ็ตการตั้งค่า Perspective Correction
        function resetPerspectiveSettings() {
            cameraFOV = { horizontal: 60, vertical: 45 }; // ใช้ค่าใหม่ที่ปรับแล้ว
            cameraHeight = 1.5;
            cameraTilt = 0;
            deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
            
            document.getElementById('cameraHeightInput').value = cameraHeight;
            
            // รีคาลิเบรต
            if (cameraActive) {
                calibrateCameraFOV();
                calibrateCameraHeight();
            }
            
            alert('รีเซ็ตการตั้งค่า Perspective Correction เรียบร้อยแล้ว (ใช้ค่าปรับปรุงใหม่)');
        }
        
        // เพิ่มข้อมูลการแสดงผลในขั้นตอนการคำนวณ
        function getAdvancedCalculationInfo() {
            return {
                fov: cameraFOV,
                height: cameraHeight,
                tilt: cameraTilt,
                orientation: deviceOrientation
            };      
        }
        
        // แสดงข้อมูลการหมุนอุปกรณ์
        function updateOrientationDisplay() {
            const info = document.getElementById('info');
            if (info) {
                const tiltText = Math.abs(cameraTilt) > 5 ? 
                    ` | เอียง: ${cameraTilt.toFixed(1)}°` : '';
                info.textContent = `จุดที่วัด: ${points.length}${tiltText}`;
            }
        }
        
        // ระบบคาลิเบรต FOV อัตโนมัติ
        async function calibrateCameraFOV() {
            if (!stream || !video.videoWidth) return;
            
            try {
                // พยายามดึงข้อมูล FOV จาก MediaStreamTrack
                const videoTrack = stream.getVideoTracks()[0];
                if (videoTrack) {
                    const settings = videoTrack.getSettings();
                    const capabilities = videoTrack.getCapabilities();
                    
                    // ประมาณ FOV จากความละเอียดและ focal length (ถ้ามี)
                    if (settings.width && settings.height) {
                        const aspectRatio = settings.width / settings.height;
                        
                        // ประมาณ FOV สำหรับกล้องมือถือทั่วไป (ปรับให้เหมาะสม)
                        if (aspectRatio > 1.5) { // กล้องแนวนอน
                            cameraFOV.horizontal = 65; // ลดจาก 75
                            cameraFOV.vertical = 50;   // ลดจาก 60
                        } else { // กล้องแนวตั้ง
                            cameraFOV.horizontal = 55; // ลดจาก 65
                            cameraFOV.vertical = 40;   // ลดจาก 50
                        }
                        
                        console.log('FOV calibrated:', cameraFOV);
                    }
                }
            } catch (error) {
                console.log('FOV calibration failed, using defaults:', error);
            }
        }
        
        // ระบบคาลิเบรตความสูงกล้องแบบไดนามิก
        function calibrateCameraHeight() {
            // ใช้ข้อมูลจากเซ็นเซอร์หรือการตั้งค่าผู้ใช้
            const userAgent = navigator.userAgent.toLowerCase();
            
            if (userAgent.includes('mobile') || userAgent.includes('android') || userAgent.includes('iphone')) {
                // มือถือ - ประมาณความสูงจากการถือ
                cameraHeight = deviceOrientation.beta < -30 ? 1.2 : // ถือสูง
                              deviceOrientation.beta > 30 ? 0.8 :   // ถือต่ำ
                              1.0; // ถือปกติ
            } else {
                // เดสก์ท็อป/แล็ปท็อป
                cameraHeight = 1.3;
            }
        }
        
        // เริ่มต้นกล้อง
        async function initCamera(deviceId = null) {
            const statusElement = document.getElementById('camera-status');
            
            // ตรวจสอบว่าเบราว์เซอร์รองรับ getUserMedia หรือไม่
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                statusElement.style.display = 'block';
                statusElement.textContent = 'เบราว์เซอร์ไม่รองรับการใช้งานกล้อง กรุณาใช้เบราว์เซอร์ที่ทันสมัยกว่านี้';
                statusElement.style.color = '#ff4757';
                return;
            }
            
            // แสดงสถานะเริ่มต้น
            statusElement.style.display = 'block';
            statusElement.textContent = 'กำลังขอสิทธิ์เข้าถึงกล้อง...';
            statusElement.style.color = '#00ff88';
            
            // ปิด stream เก่าก่อน (ถ้ามี)
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            try {
                // หากระบุ deviceId ให้ใช้โดยตรง
                if (deviceId) {
                    statusElement.textContent = 'กำลังเปิดกล้องที่เลือก...';
                    stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: { exact: deviceId },
                            width: { ideal: 1280, min: 640 },
                            height: { ideal: 720, min: 480 }
                        }
                    });
                } else {
                    // ลำดับการลองใช้กล้อง: พยายาม environment (ไม่ exact เพื่อรองรับ iOS) -> user -> ใดก็ได้
                    const cameraConfigs = [
                        {
                            name: 'กล้องหลัง',
                            constraints: {
                                video: {
                                    facingMode: { ideal: 'environment' },
                                    width: { ideal: 1280, min: 640 },
                                    height: { ideal: 720, min: 480 }
                                }
                            }
                        },
                        {
                            name: 'กล้องหน้า',
                            constraints: {
                                video: {
                                    facingMode: { ideal: 'user' },
                                    width: { ideal: 1280, min: 640 },
                                    height: { ideal: 720, min: 480 }
                                }
                            }
                        },
                        {
                            name: 'กล้องใดก็ได้',
                            constraints: {
                                video: {
                                    width: { ideal: 1280, min: 640 },
                                    height: { ideal: 720, min: 480 }
                                }
                            }
                        }
                    ];

                    let cameraOpened = false;
                    for (const config of cameraConfigs) {
                        if (cameraOpened) break;
                        try {
                            statusElement.textContent = `กำลังเปิด${config.name}...`;
                            console.log(`กำลังลอง${config.name}...`);
                            stream = await navigator.mediaDevices.getUserMedia(config.constraints);
                            if (stream && stream.getVideoTracks().length > 0) {
                                console.log(`${config.name}เปิดสำเร็จ`);
                                cameraOpened = true;
                                break;
                            }
                        } catch (configError) {
                            console.log(`${config.name}ไม่สามารถใช้ได้:`, configError.message);
                            if (stream) {
                                stream.getTracks().forEach(track => track.stop());
                                stream = null;
                            }
                        }
                    }
                    if (!cameraOpened || !stream) {
                        throw new Error('ไม่สามารถเปิดกล้องได้');
                    }
                }
                
                // ตั้งค่า video element
                statusElement.textContent = 'กำลังโหลดวิดีโอ...';
                
                // ล้าง srcObject เก่า
                if (video.srcObject) {
                    video.srcObject = null;
                }
                
                // ตั้งค่า video attributes
                video.muted = true;
                video.playsInline = true;
                video.autoplay = true;
                
                // ตั้งค่า stream ใหม่
                video.srcObject = stream;
                
                // รอให้ video พร้อม
                await new Promise((resolve, reject) => {
                    const timeout = setTimeout(() => {
                        reject(new Error('Video loading timeout'));
                    }, 10000); // timeout 10 วินาที
                    
                    video.onloadedmetadata = () => {
                        clearTimeout(timeout);
                        console.log('Video metadata loaded');
                        resolve();
                    };
                    
                    video.onerror = (error) => {
                        clearTimeout(timeout);
                        console.error('Video error:', error);
                        reject(error);
                    };
                });
                
                // เล่น video
                try {
                    await video.play();
                    console.log('Video playing');
                } catch (playError) {
                    console.log('Auto-play failed, but video is ready:', playError.message);
                }
                
                // ตั้งค่าสถานะสำเร็จ
                cameraActive = true;
                statusElement.style.display = 'none';
                console.log('กล้องเปิดสำเร็จและพร้อมใช้งาน');
                
                // เริ่มต้นระบบปรับปรุง
                initDeviceOrientation();
                await calibrateCameraFOV();
                calibrateCameraHeight();
                
                // อัปเดตรายการกล้อง
                try { await populateCameraSelect(); } catch(e) { console.log('populateCameraSelect error', e); }
                
            } catch (error) {
                console.error('ไม่สามารถเข้าถึงกล้องได้:', error);
                cameraActive = false;
                statusElement.style.display = 'block';
                statusElement.style.color = '#ff4757';
                
                // ปิด stream ถ้ามี
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    stream = null;
                }
                
                // แสดงข้อความแจ้งเตือนตามประเภทของข้อผิดพลาด
                if (error.name === 'NotAllowedError') {
                    statusElement.textContent = '❌ ผู้ใช้ปฏิเสธการเข้าถึงกล้อง กรุณาอนุญาตการใช้งานกล้องในเบราว์เซอร์';
                } else if (error.name === 'NotFoundError') {
                    statusElement.textContent = '❌ ไม่พบกล้องในอุปกรณ์นี้';
                } else if (error.name === 'NotReadableError') {
                    statusElement.textContent = '❌ กล้องถูกใช้งานโดยแอปพลิเคชันอื่น';
                } else if (error.name === 'OverconstrainedError') {
                    statusElement.textContent = '❌ การตั้งค่ากล้องไม่รองรับ';
                } else if (error.name === 'SecurityError') {
                    statusElement.textContent = '❌ ปัญหาความปลอดภัย (ต้องใช้ HTTPS)';
                } else {
                    statusElement.textContent = `❌ เกิดข้อผิดพลาด: ${error.message}`;
                }
            }
        }
        
        // เปิด/ปิดกล้อง
        function toggleCamera() {
            const statusElement = document.getElementById('camera-status');
            
            if (cameraActive) {
                // ปิดกล้อง
                if (stream) {
                    stream.getTracks().forEach(track => {
                        track.stop();
                        console.log('ปิดกล้องแล้ว');
                    });
                    video.srcObject = null;
                    stream = null;
                }
                cameraActive = false;
                statusElement.style.display = 'block';
                statusElement.textContent = '📷 กล้องปิดอยู่ - กดปุ่มเพื่อเปิดกล้อง';
                statusElement.style.color = '#ff4757';
            } else {
                // เปิดกล้อง
                initCamera();
            }
        }
        
        // ตั้งค่าโหมด
        let modeChangeInProgress = false;
        function setMode(mode, btn) {
            // ป้องกันการเปลี่ยนโหมดซ้ำ
            if (modeChangeInProgress) {
                console.log('กำลังเปลี่ยนโหมดอยู่ กรุณารอสักครู่');
                return;
            }
            
            try {
                modeChangeInProgress = true;
                console.log('กำลังเปลี่ยนโหมดเป็น:', mode);
                currentMode = mode;
                
                // ตรวจสอบว่า DOM elements พร้อมใช้งาน
                const requiredElements = ['cameraControls', 'measurementControls', 'advancedCameraControls', 'heightControls', 'calculationSteps'];
                const missingElements = requiredElements.filter(id => !document.getElementById(id));
                
                if (missingElements.length > 0) {
                    console.warn('พบ elements ที่หายไป:', missingElements);
                }
                
                // อัปเดต UI ปุ่มโหมด
                const modeButtons = document.querySelectorAll('.mode-btn');
                if (modeButtons.length === 0) {
                    throw new Error('ไม่พบปุ่มโหมด');
                }
                
                modeButtons.forEach(b => b.classList.remove('active'));
                if (btn) {
                    btn.classList.add('active');
                } else {
                    // หาปุ่มที่ตรงกับโหมดและเปิดใช้งาน
                    modeButtons.forEach(button => {
                        const buttonText = button.textContent.toLowerCase();
                        if ((mode === 'distance' && buttonText.includes('ระยะทาง')) ||
                            (mode === 'area' && buttonText.includes('พื้นที่')) ||
                            (mode === 'height' && buttonText.includes('ความสูง')) ||
                            (mode === 'angle' && buttonText.includes('มุม'))) {
                            button.classList.add('active');
                        }
                    });
                }
                
                // ล้างจุดเก่าอย่างปลอดภัย
                try {
                    clearPoints();
                } catch (clearError) {
                    console.warn('ไม่สามารถล้างจุดได้:', clearError);
                    // ล้างจุดแบบ manual
                    points = [];
                    const pointsContainer = document.getElementById('points');
                    if (pointsContainer) {
                        pointsContainer.innerHTML = '';
                    }
                }
                
                // ซ่อน UI sections ทั้งหมดก่อน
                const cameraControls = document.getElementById('cameraControls');
                const measurementControls = document.getElementById('measurementControls');
                const advancedCameraControls = document.getElementById('advancedCameraControls');
                const heightControls = document.getElementById('heightControls');
                
                // ซ่อนทั้งหมดอย่างปลอดภัย
                [cameraControls, measurementControls, advancedCameraControls, heightControls].forEach(element => {
                    if (element) element.style.display = 'none';
                });
                
                // แสดง UI sections ตามโหมด
                switch(mode) {
                    case 'distance':
                        if (cameraControls) cameraControls.style.display = 'block';
                        if (measurementControls) measurementControls.style.display = 'block';
                        if (advancedCameraControls) advancedCameraControls.style.display = 'block';
                        break;
                        
                    case 'area':
                        if (cameraControls) cameraControls.style.display = 'block';
                        if (measurementControls) measurementControls.style.display = 'block';
                        break;
                        
                    case 'height':
                        if (heightControls) heightControls.style.display = 'block';
                        break;
                        
                    case 'angle':
                        if (cameraControls) cameraControls.style.display = 'block';
                        break;
                        
                    default:
                        console.warn('โหมดไม่รู้จัก:', mode);
                        break;
                }
                
                // ซ่อนขั้นตอนการคำนวณ
                const stepsDiv = document.getElementById('calculationSteps');
                if (stepsDiv) {
                    stepsDiv.classList.remove('show');
                }
                
                // รีเซ็ตผลลัพธ์
                updateResults(0, 0, 0, 0);
                
                console.log('เปลี่ยนโหมดสำเร็จเป็น:', currentMode);
                
            } catch (error) {
                console.error('เกิดข้อผิดพลาดในการเปลี่ยนโหมด:', error);
                alert(`เกิดข้อผิดพลาดในการเปลี่ยนโหมด: ${error.message}\nกรุณาลองใหม่อีกครั้ง`);
            } finally {
                // ปลดล็อคการเปลี่ยนโหมดหลังจาก 500ms
                setTimeout(() => {
                    modeChangeInProgress = false;
                }, 500);
            }
        }
        
        // เพิ่มจุดวัด
        function addPoint(x = null, y = null) {
            if (!cameraActive) {
                alert('กรุณาเปิดกล้องก่อนใช้งาน');
                return;
            }
            
            const container = document.querySelector('.camera-container');
            const rect = container.getBoundingClientRect();
            
            // หากไม่ระบุตำแหน่ง ให้ใช้กึ่งกลางของกล้อง
            if (x === null || y === null) {
                x = rect.width / 2;
                y = rect.height / 2;
            }

            // ถ้าคลิกนอกเฟรม ให้ออก
            if (x < 0 || y < 0 || x > rect.width || y > rect.height) return;

            // จำกัดจำนวนจุดตามโหมด
            if (currentMode === 'height' && points.length >= 2) {
                alert('โหมดความสูงใช้ได้ 2 จุด (ฐานและยอด)');
                return;
            }
            if (currentMode === 'distance' && points.length >= 2) {
                alert('โหมดระยะทางใช้ตัวอย่าง 2 จุด (เริ่มต้น-สิ้นสุด)');
                return;
            }
            if (currentMode === 'angle' && points.length >= 3) {
                alert('โหมดวัดมุมใช้ได้ 3 จุด (ยอดมุม, จุดที่ 1, จุดที่ 2)');
                return;
            }
            
            // สร้างจุดใหม่
            const point = {
                id: points.length,
                x: x,
                y: y
            };
            
            points.push(point);
            
            // แสดงจุดบนหน้าจอ
            const pointElement = document.createElement('div');
            pointElement.className = 'point';
            pointElement.style.left = x + 'px';
            pointElement.style.top = y + 'px';
            pointElement.title = `จุดที่ ${point.id + 1}`;
            
            document.getElementById('points').appendChild(pointElement);
            
            // อัพเดทข้อมูล
            updateInfo();
            drawLines();
        }
        
        // ล้างจุดทั้งหมด
        function clearPoints() {
            points = [];
            document.getElementById('points').innerHTML = '';
            updateInfo();
            updateResults();
        }

        // ย้อนกลับจุดล่าสุด
        function undoPoint() {
            if (points.length === 0) return;
            points.pop();
            const pts = document.getElementById('points');
            if (pts.lastChild) pts.removeChild(pts.lastChild);
            updateInfo();
            drawLines();
        }
        
        // วาดเส้นเชื่อมจุด
        function drawLines() {
            // ลบเส้นเก่า
            document.querySelectorAll('.measurement-line').forEach(line => line.remove());
            
            if (points.length < 2) return;
            
            const container = document.getElementById('points');
            
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];
                
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                
                // คำนวณระยะทางในระนาบ 2D
                const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                
                // Advanced Perspective Correction
                const correctedDistance = applyAdvancedPerspectiveCorrection(p1, p2, pixelDistance);
                
                const line = document.createElement('div');
                line.className = 'measurement-line';
                
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                line.style.left = p1.x + 'px';
                line.style.top = p1.y + 'px';
                line.style.width = correctedDistance + 'px';
                line.style.transform = `rotate(${angle}deg)`;
                
                container.appendChild(line);
            }
            
            // เชื่อมจุดสุดท้ายกับจุดแรกสำหรับโหมดพื้นที่
            if (currentMode === 'area' && points.length > 2) {
                const p1 = points[points.length - 1];
                const p2 = points[0];
                
                const line = document.createElement('div');
                line.className = 'measurement-line';
                
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                
                // คำนวณระยะทางในระนาบ 2D
                const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                
                // Advanced Perspective Correction
                const correctedDistance = applyAdvancedPerspectiveCorrection(p1, p2, pixelDistance);
                
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                line.style.left = p1.x + 'px';
                line.style.top = p1.y + 'px';
                line.style.width = correctedDistance + 'px';
                line.style.transform = `rotate(${angle}deg)`;
                
                container.appendChild(line);
            }
        }
        
        // คำนวณผลลัพธ์
        function calculate() {
            let distance = 0;
            let area = 0;
            let height = 0;
            let angle = 0;
            
            switch (currentMode) {
                case 'distance':
                    if (points.length === 0) {
                        alert('กรุณาเพิ่มจุดวัดก่อน');
                        return;
                    }
                    if (points.length >= 2) {
                        distance = calculateDistance();
                        showCalculationSteps('distance', distance);
                    }
                    break;
                    
                case 'area':
                    if (points.length === 0) {
                        alert('กรุณาเพิ่มจุดวัดก่อน');
                        return;
                    }
                    if (points.length >= 3) {
                        area = calculateArea();
                        showCalculationSteps('area', area);
                    } else {
                        alert('ต้องมีอย่างน้อย 3 จุดสำหรับการวัดพื้นที่');
                        return;
                    }
                    break;
                    
                case 'height':
                    // โหมดความสูงใช้ Law of Cosines - ไม่ต้องใช้จุดจากกล้อง
                    height = calculateHeightFromLawOfCosines();
                    if (height > 0) {
                        showCalculationSteps('height', height);
                    } else {
                        alert('กรุณากรอกค่ามุม C และด้าน a, b ให้ถูกต้อง');
                        return;
                    }
                    break;
                    
                case 'angle':
                    if (points.length === 0) {
                        alert('กรุณาเพิ่มจุดวัดก่อน');
                        return;
                    }
                    if (points.length >= 3) {
                        angle = calculateAngle();
                        showCalculationSteps('angle', angle);
                    } else {
                        alert('ต้องมี 3 จุดสำหรับการวัดมุม');
                        return;
                    }
                    break;
            }
            
            updateResults(distance, area, height, angle);
        }
        
        // คำนวณระยะทาง
        function getScalePxPerMeter() {
            const v = parseFloat(document.getElementById('scaleInput')?.value || '100');
            return isNaN(v) || v <= 0 ? 100 : v;
        }

        function calculateDistance() {
            let totalDistance = 0;
            const s = getScalePxPerMeter();
            
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];
                
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                
                // คำนวณระยะทางในระนาบ 2D
                const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                
                // Advanced Perspective Correction
                const correctedDistance = applyAdvancedPerspectiveCorrection(p1, p2, pixelDistance, s);
                totalDistance += correctedDistance;
            }
            
            return totalDistance;
        }
        
        // Advanced Perspective Correction System (ปรับปรุงความแม่นยำ)
        function applyAdvancedPerspectiveCorrection(p1, p2, pixelDistance, scale) {
            const centerX = video.videoWidth / 2;
            const centerY = video.videoHeight / 2;
            const avgX = (p1.x + p2.x) / 2;
            const avgY = (p1.y + p2.y) / 2;
            
            // ตรวจสอบว่าอยู่ใกล้กึ่งกลางหรือไม่ - ถ้าใกล้ให้ใช้ค่าเดิม
            const distanceFromCenter = Math.sqrt(
                Math.pow((avgX - centerX) / centerX, 2) + 
                Math.pow((avgY - centerY) / centerY, 2)
            );
            
            // ถ้าอยู่ใกล้กึ่งกลาง (< 0.3) ใช้การแก้ไขน้อยมาก
            if (distanceFromCenter < 0.3) {
                const minimalCorrection = 1 + distanceFromCenter * 0.05; // แก้ไขเพียง 5%
                return (pixelDistance * minimalCorrection) / scale;
            }
            
            // สำหรับจุดที่ห่างจากกึ่งกลาง ใช้การแก้ไขแบบปรับปรุง
            
            // 1. ปรับค่า FOV ให้เหมาะสมกับกล้องจริง
            const adjustedFOV = {
                horizontal: cameraFOV.horizontal * 0.8, // ลดลง 20%
                vertical: cameraFOV.vertical * 0.8
            };
            
            // 2. คำนวณมุมจาก FOV (ใช้ tangent สำหรับความแม่นยำ)
            const horizontalAngle = ((avgX - centerX) / centerX) * (adjustedFOV.horizontal / 2) * (Math.PI / 180);
            const verticalAngle = ((avgY - centerY) / centerY) * (adjustedFOV.vertical / 2) * (Math.PI / 180);
            
            // 3. ปรับค่าตามมุมมองแบบโค้งที่อ่อนโยนกว่า
            const radialDistance = Math.sqrt(
                Math.pow((avgX - centerX) / centerX, 2) + 
                Math.pow((avgY - centerY) / centerY, 2)
            );
            
            // ลดค่า curvature factor ลงมาก
            const curvatureFactor = 1 + Math.pow(radialDistance, 1.2) * 0.15; // ลดจาก 0.4 เป็น 0.15
            
            // 4. ปรับตามมุมเอียงกล้อง (ลดผลกระทบ)
            const tiltCorrection = Math.abs(cameraTilt) > 10 ? 
                Math.cos(cameraTilt * Math.PI / 180) : 1.0; // ใช้เฉพาะเมื่อเอียงมาก
            
            // 5. ลดผลกระทบของ Distance Scaling
            const estimatedDistance = calculateDistanceToObject(avgY, centerY);
            const distanceScaling = Math.max(0.8, Math.min(1.2, estimatedDistance / 3.0)); // ลดช่วงจาก 0.5-2.0 เป็น 0.8-1.2
            
            // 6. รวมปัจจัยทั้งหมดแบบอ่อนโยน
            const finalCorrection = curvatureFactor * tiltCorrection * distanceScaling;
            
            return (pixelDistance * finalCorrection) / scale;
        }
        
        // คำนวณพื้นที่
        function calculateArea() {
            if (points.length < 3) return 0;
            
            // ใช้ Shoelace formula
            let area = 0;
            const n = points.length;
            
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                area += points[i].x * points[j].y;
                area -= points[j].x * points[i].y;
            }
            const s = getScalePxPerMeter();
            return Math.abs(area) / 2 / (s * s); // ตร.ม.
        }
        
        // คำนวณความสูง (แก้ไขปัญหาค่าต่ำเกินไป - ใช้มุมยกระดับโดยตรง)
        function calculateHeight() {
            if (points.length < 2) return 0;
            
            const p1 = points[0]; // จุดฐาน (ด้านล่าง)
            const p2 = points[points.length - 1]; // จุดยอด (ด้านบน)
            const centerY = video.videoHeight / 2;
            
            // คำนวณระยะห่างเฉลี่ยจากกล้องถึงวัตถุ
            let avgDistance;
            if (manualDistanceMode) {
                // ใช้ระยะทางที่ผู้ใช้กำหนด
                avgDistance = manualDistance;
            } else {
                // คำนวณระยะทางอัตโนมัติ
                avgDistance = (calculateDistanceToObject(p1.y, centerY) + calculateDistanceToObject(p2.y, centerY)) / 2;
            }
            
            // คำนวณความต่างของพิกเซลในแนวตั้ง
            const pixelDifference = Math.abs(p2.y - p1.y);
            
            // คำนวณมุมจากความต่างพิกเซล
            const verticalFOVRad = (cameraFOV.vertical * Math.PI) / 180;
            const pixelsPerDegree = video.videoHeight / verticalFOVRad;
            const angleInRadians = pixelDifference / pixelsPerDegree;
            
            // คำนวณความสูงด้วยตรีโกณมิติ: height = distance × tan(angle)
            let objectHeight = avgDistance * Math.tan(angleInRadians);
            
            // ปรับค่าตามระยะห่างแนวนอน (ถ้ามี)
            const dx = Math.abs(p2.x - p1.x);
            if (dx > 20) { // มีการเลื่อนแนวนอนมาก
                const horizontalCorrection = Math.cos(Math.atan(dx / video.videoWidth));
                objectHeight *= horizontalCorrection;
            }
            
            // ปรับค่าตามมุมเอียงกล้อง
            const tiltCorrection = Math.cos(cameraTilt * Math.PI / 180);
            objectHeight *= tiltCorrection;
            
            // ใช้ปัจจัยชดเชยตามระยะห่างและความสูงของวัตถุ (เฉพาะโหมดอัตโนมัติ)
            if (!manualDistanceMode) {
                const distanceCompensation = getDistanceCompensationFactor(avgDistance, objectHeight);
                objectHeight *= distanceCompensation;
            }
            
            // เพิ่มปัจจัยการปรับแต่งสำหรับความแม่นยำ (ตามข้อมูลจริง)
            const calibrationFactor = 1.2; // ปรับจากการทดสอบจริง
            objectHeight *= calibrationFactor;
            
            // ตรวจสอบและแสดงคำแนะนำตามระยะห่าง (เฉพาะโหมดอัตโนมัติ)
            if (!manualDistanceMode) {
                const distanceCheck = checkOptimalDistance(objectHeight, avgDistance);
                updateDistanceWarnings(distanceCheck);
            }
            
            // จำกัดค่าให้อยู่ในช่วงที่สมเหตุสมผล
            return Math.max(0.1, Math.min(100, objectHeight));
        }
        
        // คำนวณมุมแนวตั้งจากตำแหน่งพิกเซล (ปรับปรุงใหม่)
        function getVerticalAngleFromPixel(pixelY, centerY) {
            // ในโหมดตั้งฉาก: ใช้จุดศูนย์กลางกล้องเป็นฐาน (มุม = 0°)
            if (perpendicularMode) {
                return 0;
            }
            
            // โหมดปกติ: คำนวณมุมจากตำแหน่งพิกเซลเทียบกับจุดศูนย์กลาง
            const normalizedY = (pixelY - centerY) / centerY;
            const verticalAngleRad = normalizedY * (cameraFOV.vertical / 2) * (Math.PI / 180);
            
            // ปรับมุมตามการเอียงของกล้อง
            return verticalAngleRad + (cameraTilt * Math.PI / 180);
        }
        
        // คำนวณมุมแนวนอนจากตำแหน่งพิกเซล
        function getHorizontalAngleFromPixel(pixelX, centerX) {
            const normalizedX = (pixelX - centerX) / centerX;
            const halfFOVRad = (cameraFOV.horizontal / 2) * (Math.PI / 180);
            return Math.atan(normalizedX * Math.tan(halfFOVRad));
        }
        
        // คำนวณมุม
        function calculateAngle() {
            if (points.length < 3) return 0;
            
            const vertex = points[0]; // จุดยอดมุม
            const p1 = points[1];     // จุดที่ 1
            const p2 = points[2];     // จุดที่ 2
            
            // คำนวณเวกเตอร์จากยอดไปยังจุดต่างๆ
            const v1x = p1.x - vertex.x;
            const v1y = p1.y - vertex.y;
            const v2x = p2.x - vertex.x;
            const v2y = p2.y - vertex.y;
            
            // คำนวณมุมด้วยฟังก์ชัน atan2
            const angle1 = Math.atan2(v1y, v1x);
            const angle2 = Math.atan2(v2y, v2x);
            
            // หามุมระหว่างเวกเตอร์ทั้งสอง
            let angleDiff = Math.abs(angle2 - angle1);
            
            // แปลงเป็นองศา
            angleDiff = angleDiff * (180 / Math.PI);
            
            // ให้มุมอยู่ในช่วง 0-180 องศา
            if (angleDiff > 180) {
                angleDiff = 360 - angleDiff;
            }
            
            return angleDiff;
        }
        
        // แสดงขั้นตอนการคำนวณ
        function showCalculationSteps(mode, result) {
            const stepsDiv = document.getElementById('calculationSteps');
            const contentDiv = document.getElementById('stepsContent');
            const s = getScalePxPerMeter();
            
            let stepsHTML = '';
            
            switch(mode) {
                case 'distance':
                    if (points.length >= 2) {
                        const p1 = points[0];
                        const p2 = points[1];
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const pixelDistance = Math.sqrt(dx * dx + dy * dy);
                        
                        const centerY = video.videoHeight / 2;
                        const avgY = (p1.y + p2.y) / 2;
                        const distanceFromCenter = Math.abs(avgY - centerY);
                        const perspectiveFactor = 1 + (distanceFromCenter / centerY) * 0.3;
                        const depthFactor = avgY > centerY ? 1 + ((avgY - centerY) / centerY) * 0.5 : 1;
                        
                        const centerX = video.videoWidth / 2;
                        const avgX = (p1.x + p2.x) / 2;
                        const avgYPos = (p1.y + p2.y) / 2;
                        const estimatedDistance = calculateDistanceToObject(avgYPos, centerY);
                        const radialDistance = Math.sqrt(
                            Math.pow((avgX - centerX) / centerX, 2) + 
                            Math.pow((avgYPos - centerY) / centerY, 2)
                        );
                        const curvatureFactor = 1 + Math.pow(radialDistance, 1.5) * 0.4;
                        const tiltCorrection = Math.cos(cameraTilt * Math.PI / 180);
                        const distanceScaling = Math.max(0.5, Math.min(2.0, estimatedDistance / 3.0));
                        
                        stepsHTML = `
                            <div class="step-item">
                                <span class="step-number">ขั้นที่ 1:</span> หาระยะทางในระนาบ 2D
                                <div class="step-formula">Δx = ${dx} px, Δy = ${dy} px</div>
                                <div class="step-formula">d₂D = √(Δx² + Δy²) = ${pixelDistance.toFixed(2)} px</div>
                            </div>
                            <div class="step-item">
                                <span class="step-number">ขั้นที่ 2:</span> Advanced Perspective Correction
                                <div class="step-formula">FOV: H=${cameraFOV.horizontal}°, V=${cameraFOV.vertical}°</div>
                                <div class="step-formula">ระยะห่างประมาณ = ${estimatedDistance.toFixed(2)} ม.</div>
                                <div class="step-formula">ปัจจัยโค้ง = ${curvatureFactor.toFixed(3)}</div>
                                <div class="step-formula">แก้ไขมุมเอียง = ${tiltCorrection.toFixed(3)} (${cameraTilt.toFixed(1)}°)</div>
                            </div>
                            <div class="step-item">
                                <span class="step-number">ขั้นที่ 3:</span> คำนวณระยะทางจริง
                                <div class="step-formula">การปรับแต่งรวม = ${(curvatureFactor * tiltCorrection * distanceScaling).toFixed(3)}</div>
                                <div class="step-formula">ระยะทางจริง = (${pixelDistance.toFixed(2)} × ${(curvatureFactor * tiltCorrection * distanceScaling).toFixed(3)}) ÷ ${s} = ${result.toFixed(3)} ม.</div>
                            </div>
                        `;
                    }
                    break;
                    
                case 'height':
                    if (result > 0) {
                        const angleC = parseFloat(document.getElementById('angleInput')?.value || '90');
                        const sideA = parseFloat(document.getElementById('sideAInput')?.value || '3.0');
                        const sideB = parseFloat(document.getElementById('sideBInput')?.value || '4.0');
                        const angleCRad = (angleC * Math.PI) / 180;
                        const cSquared = (sideA * sideA) + (sideB * sideB) - (2 * sideA * sideB * Math.cos(angleCRad));
                        
                        stepsHTML = `
                            <div class="step-item">
                                <span class="step-number">📐 Law of Cosines:</span> การคำนวณความสูง
                                <div class="step-formula"><strong>สูตร:</strong> c² = a² + b² - 2ab cos(C)</div>
                                <div class="step-formula"><strong>ค่าที่ป้อน:</strong> มุม C = ${angleC}°, ด้าน a = ${sideA} ม., ด้าน b = ${sideB} ม.</div>
                            </div>
                            <div class="step-item">
                                <span class="step-number">ขั้นที่ 1:</span> คำนวณ cos(${angleC}°)
                                <div class="step-formula">cos(${angleC}°) = ${Math.cos(angleCRad).toFixed(6)}</div>
                            </div>
                            <div class="step-item">
                                <span class="step-number">ขั้นที่ 2:</span> คำนวณแต่ละส่วนของสูตร
                                <div class="step-formula">a² = ${sideA}² = ${(sideA * sideA).toFixed(3)}</div>
                                <div class="step-formula">b² = ${sideB}² = ${(sideB * sideB).toFixed(3)}</div>
                                <div class="step-formula">2ab cos(C) = 2 × ${sideA} × ${sideB} × ${Math.cos(angleCRad).toFixed(6)} = ${(2 * sideA * sideB * Math.cos(angleCRad)).toFixed(6)}</div>
                            </div>
                            <div class="step-item">
                                <span class="step-number">ขั้นที่ 3:</span> คำนวณ c²
                                <div class="step-formula">c² = ${(sideA * sideA).toFixed(3)} + ${(sideB * sideB).toFixed(3)} - ${(2 * sideA * sideB * Math.cos(angleCRad)).toFixed(6)}</div>
                                <div class="step-result">c² = ${cSquared.toFixed(6)}</div>
                            </div>
                            <div class="step-item">
                                <span class="step-number">ขั้นที่ 4:</span> ผลลัพธ์สุดท้าย
                                <div class="step-result">ความสูง (c) = √${cSquared.toFixed(6)} = <strong>${result.toFixed(3)} เมตร</strong></div>
                                ${cSquared < 0 ? '<div style="color: #ff4757; font-weight: bold;">⚠️ ค่าที่ป้อนเข้าไม่เป็นไปตามกฎของสามเหลี่ยม</div>' : ''}
                            </div>
                        `;
                    }
                    break;
                    
                case 'angle':
                    if (points.length >= 3) {
                        const vertex = points[0]; // จุดยอดมุม
                        const p1 = points[1];     // จุดที่ 1
                        const p2 = points[2];     // จุดที่ 2
                        
                        // คำนวณเวกเตอร์จากยอดไปยังจุดต่างๆ
                        const v1x = p1.x - vertex.x;
                        const v1y = p1.y - vertex.y;
                        const v2x = p2.x - vertex.x;
                        const v2y = p2.y - vertex.y;
                        
                        // คำนวณมุมด้วยฟังก์ชัน atan2
                        const angle1 = Math.atan2(v1y, v1x);
                        const angle2 = Math.atan2(v2y, v2x);
                        
                        // หามุมระหว่างเวกเตอร์ทั้งสอง
                        let angleDiff = Math.abs(angle2 - angle1);
                        
                        // แปลงเป็นองศา
                        angleDiff = angleDiff * (180 / Math.PI);
                        
                        // ให้มุมอยู่ในช่วง 0-180 องศา
                        if (angleDiff > 180) {
                            angleDiff = 360 - angleDiff;
                        }
                        
                        stepsHTML = `
                            <div class="step-item">
                                <span class="step-number">ขั้นที่ 1:</span> หาเวกเตอร์จากยอดมุม
                                <div class="step-formula">เวกเตอร์ 1: (${v1x}, ${v1y})</div>
                                <div class="step-formula">เวกเตอร์ 2: (${v2x}, ${v2y})</div>
                            </div>
                            <div class="step-item">
                                <span class="step-number">ขั้นที่ 2:</span> ใช้ฟังก์ชัน arctan
                                <div class="step-formula">θ₁ = arctan(${v1y}/${v1x})</div>
                                <div class="step-formula">θ₂ = arctan(${v2y}/${v2x})</div>
                            </div>
                            <div class="step-item">
                                <span class="step-number">ขั้นที่ 3:</span> หามุมระหว่างเวกเตอร์
                                <div class="step-formula">มุม = |θ₂ - θ₁|</div>
                                <div class="step-result">มุม = ${result.toFixed(2)}°</div>
                            </div>
                        `;
                    }
                    break;
                    
                case 'area':
                    stepsHTML = `
                        <div class="step-item">
                            <span class="step-number">ขั้นที่ 1:</span> ใช้สูตร Shoelace Formula
                            <div class="step-formula">Area = ½|∑(xᵢyᵢ₊₁ - xᵢ₊₁yᵢ)|</div>
                        </div>
                        <div class="step-item">
                            <span class="step-number">ขั้นที่ 2:</span> คำนวณจากจุดทั้งหมด ${points.length} จุด
                            <div class="step-result">พื้นที่ = ${result.toFixed(2)} ตร.ม.</div>
                        </div>
                    `;
                    break;
            }
            
            contentDiv.innerHTML = stepsHTML;
            stepsDiv.classList.add('show');
        }
        
        // อัพเดทข้อมูลการวัด
        function updateInfo() {
            const info = document.getElementById('info');
            const tiltText = Math.abs(cameraTilt) > 5 ? 
                ` | เอียง: ${cameraTilt.toFixed(1)}°` : '';
            
            if (currentMode === 'height' && points.length >= 1) {
                const centerY = video.videoHeight / 2;
                const lastPoint = points[points.length - 1];
                const distanceToObject = calculateDistanceToObject(lastPoint.y, centerY);
                info.textContent = `จุดที่วัด: ${points.length} | ระยะ: ${distanceToObject.toFixed(1)}ม.${tiltText}`;
            } else {
                info.textContent = `จุดที่วัด: ${points.length}${tiltText}`;
            }
        }
        
        // อัพเดตผลลัพธ์
        function updateResults(distance = 0, area = 0, height = 0, angle = 0) {
            const distanceEl = document.getElementById('distance');
            const areaEl = document.getElementById('area');
            const heightEl = document.getElementById('height');
            const angleEl = document.getElementById('angle');
            const pointCountEl = document.getElementById('point-count');
            
            if (distanceEl) distanceEl.textContent = distance.toFixed(2) + ' ม.';
            if (areaEl) areaEl.textContent = area.toFixed(2) + ' ตร.ม.';
            if (heightEl) heightEl.textContent = height.toFixed(2) + ' ม.';
            if (angleEl) angleEl.textContent = angle.toFixed(1) + '°';
            if (pointCountEl) pointCountEl.textContent = points.length;
            
            // Only show object distance for non-height modes or when in height mode with points
            const objectDistanceEl = document.getElementById('object-distance');
            if (objectDistanceEl) {
                if (currentMode !== 'height') {
                    if (points.length >= 2) {
                        const centerY = video.videoHeight / 2;
                        const p1 = points[0];
                        const p2 = points[points.length - 1];
                        const baseDistance = calculateDistanceToObject(p1.y, centerY);
                        const topDistance = calculateDistanceToObject(p2.y, centerY);
                        const avgDistance = (baseDistance + topDistance) / 2;
                        objectDistanceEl.textContent = avgDistance.toFixed(1) + ' ม.';
                    } else {
                        objectDistanceEl.textContent = '0 ม.';
                    }
                } else {
                    // For height mode with Law of Cosines, show the calculated height
                    objectDistanceEl.textContent = height > 0 ? height.toFixed(2) + ' ม.' : '0 ม.';
                }
            }
        }
        
        // ตรวจสอบสถานะกล้องเป็นระยะ
        function checkCameraStatus() {
            if (stream) {
                const videoTrack = stream.getVideoTracks()[0];
                if (videoTrack && videoTrack.readyState === 'ended') {
                    console.log('กล้องถูกปิดจากภายนอก');
                    cameraActive = false;
                    const statusElement = document.getElementById('camera-status');
                    statusElement.style.display = 'block';
                    statusElement.textContent = '📷 กล้องปิดอยู่ - กดปุ่มเพื่อเปิดกล้อง';
                    statusElement.style.color = '#ff4757';
                }
            }
        }
        
        // รองรับแตะที่หน้าวิดีโอเพื่อเพิ่มจุดตามตำแหน่ง
        (function setupTapToAdd() {
            const container = document.querySelector('.camera-container');
            let lastAddTs = 0;
            function addPointFromEvent(e) {
                if (!cameraActive) return;
                const now = Date.now();
                if (now - lastAddTs < 250) return; // debounce 250ms
                const rect = container.getBoundingClientRect();
                let clientX, clientY;
                if (e.touches && e.touches.length) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                if (calibrationMode) {
                    handleCalibrationTap(x, y);
                } else {
                    addPoint(x, y);
                }
                lastAddTs = now;
            }
            container.addEventListener('click', addPointFromEvent);
            container.addEventListener('touchstart', function(e){ addPointFromEvent(e); }, { passive: true });
        })();
        
        // ตรวจสอบและแนะนำระยะการวัดที่เหมาะสม
        function checkOptimalDistance(estimatedHeight, currentDistance) {
            const warnings = [];
            const suggestions = [];
            
            // คำนวณระยะที่เหมาะสมตามความสูงของวัตถุ
            const optimalDistance = Math.max(2, Math.min(estimatedHeight * 2, 15));
            
            if (currentDistance < 2) {
                warnings.push("⚠️ ระยะใกล้เกินไป อาจได้ผลไม่แม่นยำ");
                suggestions.push(`📏 แนะนำให้ถอยห่างเป็น ${optimalDistance.toFixed(1)} เมตร`);
            } else if (currentDistance > 10 && estimatedHeight < 5) {
                warnings.push("⚠️ ระยะไกลเกินไปสำหรับวัตถุขนาดนี้");
                suggestions.push(`📏 แนะนำให้เข้าใกล้เป็น ${optimalDistance.toFixed(1)} เมตร`);
            } else if (estimatedHeight > 8 && currentDistance < estimatedHeight * 1.5) {
                warnings.push("⚠️ วัตถุสูงมาก ต้องการระยะห่างมากขึ้น");
                suggestions.push(`📏 สำหรับวัตถุสูง ${estimatedHeight.toFixed(1)}ม. แนะนำระยะ ${optimalDistance.toFixed(1)} เมตร`);
            }
            
            return { warnings, suggestions, optimalDistance };
        }
        
        // ปรับปัจจัยการคำนวณตามระยะห่าง
        function getDistanceCompensationFactor(distance, objectHeight) {
            let compensationFactor = 1.0;
            
            // สำหรับระยะไกล (>10ม.) เพิ่มปัจจัยชดเชย
            if (distance > 10) {
                compensationFactor = 1.0 + (distance - 10) * 0.05; // เพิ่ม 5% ทุก 1 เมตรที่เกิน 10ม.
            }
            
            // สำหรับวัตถุสูงมาก (>8ม.) ปรับปัจจัยเพิ่มเติม
            if (objectHeight > 8) {
                compensationFactor *= 1.0 + (objectHeight - 8) * 0.02; // เพิ่ม 2% ทุก 1 เมตรที่เกิน 8ม.
            }
            
            // สำหรับระยะใกล้ (<3ม.) ลดปัจจัย
            if (distance < 3) {
                compensationFactor *= 0.9 + distance * 0.033; // ลดลงเมื่อระยะใกล้
            }
            
            return compensationFactor;
        }
        
        // แสดงคำเตือนและคำแนะนำเกี่ยวกับระยะการวัด
        function updateDistanceWarnings(distanceCheck) {
            const warningElement = document.getElementById('distance-warnings');
            if (!warningElement) return;
            
            let warningHTML = '';
            
            if (distanceCheck.warnings.length > 0 || distanceCheck.suggestions.length > 0) {
                warningHTML = '<div class="distance-warnings">';
                
                distanceCheck.warnings.forEach(warning => {
                    warningHTML += `<div class="warning-item">${warning}</div>`;
                });
                
                distanceCheck.suggestions.forEach(suggestion => {
                    warningHTML += `<div class="suggestion-item">${suggestion}</div>`;
                });
                
                warningHTML += '</div>';
            }
            
            warningElement.innerHTML = warningHTML;
        }
        
        // โหมดคาลิเบรต: แตะ 2 จุดบนวิดีโอ แล้วกรอกความยาวจริง (เมตร) เพื่อคำนวณสเกล px/ม.
        function toggleCalibration() {
            calibrationMode = !calibrationMode;
            const btn = document.getElementById('calibBtn');
            const statusElement = document.getElementById('camera-status');
            if (calibrationMode) {
                calibrationPoints = [];
                removeCalibrationMarkers();
                btn.textContent = '✅ กำลังคาลิเบรต... (แตะ 2 จุด)';
                statusElement.style.display = 'block';
                statusElement.textContent = '🎯 โหมดคาลิเบรต: แตะ 2 จุดที่ขอบของวัตถุ';
                statusElement.style.color = '#2ed573';
            } else {
                btn.textContent = '🎯 คาลิเบรตสเกล';
                if (!cameraActive) {
                    statusElement.style.display = 'block';
                    statusElement.textContent = '📷 กล้องปิดอยู่ - กดปุ่มเพื่อเปิดกล้อง';
                    statusElement.style.color = '#ffeb3b';
                } else {
                    statusElement.style.display = 'none';
                }
                removeCalibrationMarkers();
            }
        }
        
        // คาลิเบรตอัตโนมัติตามระยะห่างจากกึ่งกลาง
        async function calibrateCameraFOV() {
            if (!stream || !video.videoWidth) return;
            
            try {
                // พยายามดึงข้อมูล FOV จาก MediaStreamTrack
                const videoTrack = stream.getVideoTracks()[0];
                if (videoTrack) {
                    const settings = videoTrack.getSettings();
                    const capabilities = videoTrack.getCapabilities();
                    
                    // ประมาณ FOV จากความละเอียดและ focal length (ถ้ามี)
                    if (settings.width && settings.height) {
                        const aspectRatio = settings.width / settings.height;
                        
                        // ประมาณ FOV สำหรับกล้องมือถือทั่วไป (ปรับให้เหมาะสม)
                        if (aspectRatio > 1.5) { // กล้องแนวนอน
                            cameraFOV.horizontal = 65; // ลดจาก 75
                            cameraFOV.vertical = 50;   // ลดจาก 60
                        } else { // กล้องแนวตั้ง
                            cameraFOV.horizontal = 55; // ลดจาก 65
                            cameraFOV.vertical = 40;   // ลดจาก 50
                        }
                        
                        console.log('FOV calibrated:', cameraFOV);
                    }
                }
            } catch (error) {
                console.log('FOV calibration failed, using defaults:', error);
            }
        }
        
        // คาลิเบรตอัตโนมัติโดยใช้วัตถุอ้างอิงทั่วไป
        function autoCalibrate() {
            const options = [
                { name: "บัตรเครดิต", width: 8.56, height: 5.398, unit: "ซม." },
                { name: "กระดาษ A4", width: 21, height: 29.7, unit: "ซม." },
                { name: "เหรียญ 10 บาท", width: 2.6, height: 2.6, unit: "ซม." },
                { name: "มือถือ iPhone", width: 7.1, height: 14.7, unit: "ซม." },
                { name: "ปากกา", width: 1.4, height: 14, unit: "ซม." }
            ];
            
            let optionText = "เลือกวัตถุอ้างอิงที่มีในภาพ:\n";
            options.forEach((opt, i) => {
                optionText += `${i + 1}. ${opt.name} (${opt.width}×${opt.height} ${opt.unit})\n`;
            });
            
            const choice = prompt(optionText + "\nกรอกหมายเลข 1-5:");
            const selectedIndex = parseInt(choice) - 1;
            
            if (selectedIndex >= 0 && selectedIndex < options.length) {
                const selected = options[selectedIndex];
                alert(`เลือก: ${selected.name}\nขั้นตอนต่อไป: วางวัตถุในภาพแล้วแตะ 2 จุดที่ขอบของวัตถุ`);
                
                // เริ่มโหมดคาลิเบรตพิเศษ
                calibrationMode = true;
                calibrationPoints = [];
                window.calibrationReference = selected;
                
                const statusElement = document.getElementById('camera-status');
                statusElement.style.display = 'block';
                statusElement.textContent = `🎯 แตะ 2 จุดที่ขอบของ${selected.name} (${selected.width} ${selected.unit})`;
                statusElement.style.color = '#2ed573';
            }
        }

        function handleCalibrationTap(x, y) {
            const container = document.querySelector('.camera-container');
            const rect = container.getBoundingClientRect();
            if (x < 0 || y < 0 || x > rect.width || y > rect.height) return;

            // วาด marker ชั่วคราว
            const marker = document.createElement('div');
            marker.className = 'calib-point';
            marker.style.position = 'absolute';
            marker.style.width = '10px';
            marker.style.height = '10px';
            marker.style.borderRadius = '50%';
            marker.style.background = '#2ed573';
            marker.style.border = '2px solid #145a32';
            marker.style.left = (x - 5) + 'px';
            marker.style.top = (y - 5) + 'px';
            document.getElementById('points').appendChild(marker);

            calibrationPoints.push({ x, y });
            if (calibrationPoints.length === 2) {
                const [p1, p2] = calibrationPoints;
                const pixelDist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                
                let realMeters;
                if (window.calibrationReference) {
                    // ใช้วัตถุอ้างอิงที่เลือกไว้
                    const ref = window.calibrationReference;
                    realMeters = ref.width / 100; // แปลง ซม. เป็น เมตร
                    alert(`ใช้ขนาดของ${ref.name}: ${ref.width} ${ref.unit} = ${realMeters} เมตร`);
                } else {
                    // ให้ผู้ใช้กรอกเอง
                    const realMetersStr = prompt(`ระยะพิกเซล ≈ ${pixelDist.toFixed(2)} px\nกรอกความยาวจริง (เมตร):`, '1');
                    realMeters = parseFloat(realMetersStr);
                }
                
                if (!isNaN(realMeters) && realMeters > 0) {
                    const scale = pixelDist / realMeters; // px ต่อ 1 เมตร
                    const scaleInput = document.getElementById('scaleInput');
                    scaleInput.value = Math.max(1, Math.round(scale));
                    try { localStorage.setItem('scalePxPerMeter', scaleInput.value); } catch {}
                    updateRuler();
                    alert(`✅ คาลิเบรตสำเร็จ!\nสเกลใหม่: ${scaleInput.value} px/ม.\nความแม่นยำจะดีขึ้น`);
                } else {
                    alert('ค่าไม่ถูกต้อง ยกเลิกการคาลิเบรต');
                }
                
                // ออกจากโหมดคาลิเบรตและล้าง marker
                calibrationMode = false;
                window.calibrationReference = null;
                const btn = document.getElementById('calibBtn');
                btn.textContent = '🎯 คาลิเบรตสเกล';
                const statusElement = document.getElementById('camera-status');
                statusElement.style.display = 'none';
                removeCalibrationMarkers();
            }
        }

        function removeCalibrationMarkers() {
            calibrationPoints = [];
            document.querySelectorAll('.calib-point').forEach(el => el.remove());
        }

        // อัปเดตสเกลไม้บรรทัดบนหน้ากล้อง
        function updateRuler() {
            const bar = document.getElementById('rulerBar');
            const label = document.getElementById('rulerLabel');
            const container = document.querySelector('.camera-container');
            if (!bar || !label || !container) return;
            const rect = container.getBoundingClientRect();
            const scaleInput = document.getElementById('scaleInput');
            const pxPerMeter = Math.max(1, parseFloat(scaleInput.value) || 100);

            // ความกว้างสูงสุดของแถบ และความกว้างที่ใช้จริง (พยายามให้ยาว = 1 เมตร หากพื้นที่พอ)
            const maxBar = Math.max(80, Math.min(rect.width - 40, 240));
            const targetWidth = pxPerMeter; // 1 เมตร
            const barWidth = Math.round(Math.max(80, Math.min(targetWidth, maxBar)));
            bar.style.width = barWidth + 'px';
            label.textContent = `สเกล: 1 ม. ≈ ${pxPerMeter} px` + (barWidth < pxPerMeter ? ' (แสดงย่อ)' : '');

            // ลบ tick เดิม
            bar.querySelectorAll('.tick, .tick-label').forEach(el => el.remove());

            // วาด tick ตามสเกลที่มีพื้นที่พอ
            const maxMetersShown = barWidth / pxPerMeter; // เมตรที่มองเห็นบนแถบ
            // เลือก step ย่อย
            let minorStep = 0.5; // เริ่มจาก 0.5 ม.
            if (pxPerMeter * 0.5 < 40) {
                // ถ้า 0.5 เมตรแคบเกินไป ให้ใช้เฉพาะหลัก 1 เมตร
                minorStep = 1;
            } else if (pxPerMeter * 0.25 >= 40 && maxMetersShown >= 1) {
                // ถ้าพอพื้นที่ แสดง 0.25 ด้วย
                minorStep = 0.25;
            }

            // วาดจาก 0 ถึงความยาวที่แสดงได้
            const endMeters = Math.max(minorStep, Math.min(1, maxMetersShown));
            for (let m = minorStep; m <= endMeters + 1e-6; m += minorStep) {
                const x = Math.round(m * pxPerMeter);
                if (x > barWidth) break;
                const isMajor = Math.abs(m - Math.round(m)) < 1e-6; // ระยะเต็มเมตร
                const isHalf = Math.abs(m - 0.5) < 1e-6; // 0.5 เมตรแรก

                const tick = document.createElement('div');
                tick.className = 'tick ' + (isMajor ? 'major' : 'minor');
                tick.style.left = x + 'px';
                bar.appendChild(tick);

                // แสดง label ที่ 0.5 ม. และทุกๆ 1 ม.
                if (isMajor || isHalf) {
                    const lbl = document.createElement('div');
                    lbl.className = 'tick-label';
                    lbl.style.left = x + 'px';
                    lbl.textContent = (isHalf ? '0.5 ม.' : `${Math.round(m)} ม.`);
                    bar.appendChild(lbl);
                }
            }
        }

        // เริ่มต้นแอป (ไม่เปิดกล้องอัตโนมัติ เพื่อหลีกเลี่ยง autoplay block บางเคส)
        window.addEventListener('load', () => {
            console.log('เริ่มต้นแอปวัดพื้นที่และความสูง');
            
            // ตั้งค่าสถานะเริ่มต้น
            const statusElement = document.getElementById('camera-status');
            
            // ตั้งค่าโหมดเริ่มต้น
            setMode('distance');
            
            // ตรวจสอบสถานะกล้องทุก 2 วินาที
            setInterval(checkCameraStatus, 2000);
            
            // ลงทะเบียน Service Worker
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js').then(() => {
                    console.log('Service Worker registered');
                }).catch(err => console.log('SW registration failed', err));
            }

            // Restore/Save scale from localStorage
            const scaleInput = document.getElementById('scaleInput');
            try {
                const saved = localStorage.getItem('scalePxPerMeter');
                if (saved) scaleInput.value = saved;
            } catch {}
            updateRuler();
            scaleInput.addEventListener('input', () => {
                try { localStorage.setItem('scalePxPerMeter', scaleInput.value); } catch {}
                updateRuler();
            });
            window.addEventListener('resize', () => {
                updateRuler();
            });
            
            console.log('แอปเริ่มต้นเรียบร้อยแล้ว');
        });
        
        // ฟังก์ชันจัดการรายการกล้อง
        async function populateCameraSelect() {
            const select = document.getElementById('cameraSelect');
            if (!select) return;
            
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                
                select.innerHTML = '';
                videoDevices.forEach((device, index) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `กล้อง ${index + 1}`;
                    select.appendChild(option);
                });
                
                if (videoDevices.length > 1) {
                    document.getElementById('refreshBtn').style.display = 'inline-block';
                }
            } catch (error) {
                console.log('ไม่สามารถดึงรายการกล้องได้:', error);
            }
        }
        
        // ฟังก์ชันเปลี่ยนกล้อง
        async function onCameraChange(deviceId) {
            if (deviceId && cameraActive) {
                await initCamera(deviceId);
            }
        }
        
        // ฟังก์ชันรีเฟรชรายการกล้อง
        async function refreshCameras() {
            await populateCameraSelect();
            alert('รีเฟรชรายการกล้องเรียบร้อยแล้ว');
        }
        
        // คำนวณระยะห่างจากกล้องถึงวัตถุ (ปรับปรุงใหม่ - ใช้จุดศูนย์กลางกล้องเป็นฐาน)
        function calculateDistanceToObject(pixelY, centerY) {
            // ในโหมดตั้งฉาก: ใช้จุดศูนย์กลางกล้องเป็นฐาน (มุม = 0°)
            if (perpendicularMode) {
                // กล้องตั้งฉากกับพื้น: ระยะห่าง = ความสูงกล้อง / tan(0°) = ไม่สิ้นสุด
                // ใช้ระยะห่างคงที่ตามความสูงกล้อง (สมมติว่าวัตถุอยู่ห่างจากกล้องตามสัดส่วน)
                const baseDistance = cameraHeight * 2.0; // สมมติว่าวัตถุอยู่ห่างจากกล้อง 2 เท่าของความสูงกล้อง
                return Math.max(1.0, Math.min(20, baseDistance));
            }
            
            // โหมดปกติ: คำนวณมุมจากตำแหน่งพิกเซลเทียบกับจุดศูนย์กลาง
            const normalizedY = (pixelY - centerY) / centerY;
            const verticalAngleRad = normalizedY * (cameraFOV.vertical / 2) * (Math.PI / 180);
            
            // ปรับมุมตามการเอียงของกล้อง
            const adjustedAngle = verticalAngleRad + (cameraTilt * Math.PI / 180);
            
            // กรณีมุมน้อยกว่า 3 องศา (เกือบขนานกับพื้น)
            if (Math.abs(adjustedAngle) < 0.05) {
                return cameraHeight / Math.tan(0.05); // ประมาณ 30 เมตร
            }
            
            // คำนวณระยะห่างจริงด้วยตรีโกณมิติ
            const distance = Math.abs(cameraHeight / Math.tan(adjustedAngle));
            
            // จำกัดระยะห่างให้อยู่ในช่วงที่สมเหตุสมผล (0.5-50 เมตร)
            return Math.max(0.5, Math.min(50, distance));
        }
        
        // คำนวณพื้นที่
        function calculateArea() {
            if (points.length < 3) return 0;
            
            // ใช้ Shoelace formula
            let area = 0;
            const n = points.length;
            
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                area += points[i].x * points[j].y;
                area -= points[j].x * points[i].y;
            }
            const s = getScalePxPerMeter();
            return Math.abs(area) / 2 / (s * s); // ตร.ม.
        }
        
        // คำนวณความสูง (แก้ไขปัญหาค่าต่ำเกินไป - ใช้มุมยกระดับโดยตรง)
        function calculateHeight() {
            if (points.length < 2) return 0;
            
            const p1 = points[0]; // จุดฐาน (ด้านล่าง)
            const p2 = points[points.length - 1]; // จุดยอด (ด้านบน)
            const centerY = video.videoHeight / 2;
            
            // คำนวณระยะห่างเฉลี่ยจากกล้องถึงวัตถุ
            let avgDistance;
            if (manualDistanceMode) {
                // ใช้ระยะทางที่ผู้ใช้กำหนด
                avgDistance = manualDistance;
            } else {
                // คำนวณระยะทางอัตโนมัติ
                avgDistance = (calculateDistanceToObject(p1.y, centerY) + calculateDistanceToObject(p2.y, centerY)) / 2;
            }
            
            // คำนวณความต่างของพิกเซลในแนวตั้ง
            const pixelDifference = Math.abs(p2.y - p1.y);
            
            // คำนวณมุมจากความต่างพิกเซล
            const verticalFOVRad = (cameraFOV.vertical * Math.PI) / 180;
            const pixelsPerDegree = video.videoHeight / verticalFOVRad;
            const angleInRadians = pixelDifference / pixelsPerDegree;
            
            // คำนวณความสูงด้วยตรีโกณมิติ: height = distance × tan(angle)
            let objectHeight = avgDistance * Math.tan(angleInRadians);
            
            // ปรับค่าตามระยะห่างแนวนอน (ถ้ามี)
            const dx = Math.abs(p2.x - p1.x);
            if (dx > 20) { // มีการเลื่อนแนวนอนมาก
                const horizontalCorrection = Math.cos(Math.atan(dx / video.videoWidth));
                objectHeight *= horizontalCorrection;
            }
            
            // ปรับค่าตามมุมเอียงกล้อง
            const tiltCorrection = Math.cos(cameraTilt * Math.PI / 180);
            objectHeight *= tiltCorrection;
            
            // ใช้ปัจจัยชดเชยตามระยะห่างและความสูงของวัตถุ (เฉพาะโหมดอัตโนมัติ)
            if (!manualDistanceMode) {
                const distanceCompensation = getDistanceCompensationFactor(avgDistance, objectHeight);
                objectHeight *= distanceCompensation;
            }
            
            // เพิ่มปัจจัยการปรับแต่งสำหรับความแม่นยำ (ตามข้อมูลจริง)
            const calibrationFactor = 1.2; // ปรับจากการทดสอบจริง
            objectHeight *= calibrationFactor;
            
            // ตรวจสอบและแสดงคำแนะนำตามระยะห่าง (เฉพาะโหมดอัตโนมัติ)
            if (!manualDistanceMode) {
                const distanceCheck = checkOptimalDistance(objectHeight, avgDistance);
                updateDistanceWarnings(distanceCheck);
            }
            
            // จำกัดค่าให้อยู่ในช่วงที่สมเหตุสมผล
            return Math.max(0.1, Math.min(100, objectHeight));
        }
        
        // คำนวณมุมแนวตั้งจากตำแหน่งพิกเซล (ปรับปรุงใหม่)
        function getVerticalAngleFromPixel(pixelY, centerY) {
            // ในโหมดตั้งฉาก: ใช้จุดศูนย์กลางกล้องเป็นฐาน (มุม = 0°)
            if (perpendicularMode) {
                return 0;
            }
            
            // โหมดปกติ: คำนวณมุมจากตำแหน่งพิกเซลเทียบกับจุดศูนย์กลาง
            const normalizedY = (pixelY - centerY) / centerY;
            const verticalAngleRad = normalizedY * (cameraFOV.vertical / 2) * (Math.PI / 180);
            
            // ปรับมุมตามการเอียงของกล้อง
            return verticalAngleRad + (cameraTilt * Math.PI / 180);
        }
        
        // คำนวณมุมแนวนอนจากตำแหน่งพิกเซล
        function getHorizontalAngleFromPixel(pixelX, centerX) {
            const normalizedX = (pixelX - centerX) / centerX;
            const halfFOVRad = (cameraFOV.horizontal / 2) * (Math.PI / 180);
            return Math.atan(normalizedX * Math.tan(halfFOVRad));
        }
        
        // คำนวณมุม
        function calculateAngle() {
            if (points.length < 3) return 0;
            
            const vertex = points[0]; // จุดยอดมุม
            const p1 = points[1];     // จุดที่ 1
            const p2 = points[2];     // จุดที่ 2
            
            // คำนวณเวกเตอร์จากยอดไปยังจุดต่างๆ
            const v1x = p1.x - vertex.x;
            const v1y = p1.y - vertex.y;
            const v2x = p2.x - vertex.x;
            const v2y = p2.y - vertex.y;
            
            // คำนวณมุมด้วยฟังก์ชัน atan2
            const angle1 = Math.atan2(v1y, v1x);
            const angle2 = Math.atan2(v2y, v2x);
            
            // หามุมระหว่างเวกเตอร์ทั้งสอง
            let angleDiff = Math.abs(angle2 - angle1);
            
            // แปลงเป็นองศา
            angleDiff = angleDiff * (180 / Math.PI);
            
            // ให้มุมอยู่ในช่วง 0-180 องศา
            if (angleDiff > 180) {
                angleDiff = 360 - angleDiff;
            }
            
            return angleDiff;
        }
        
        // เปิด/ปิดโหมดกำหนดระยะทางเอง
        function toggleManualDistance() {
            manualDistanceMode = !manualDistanceMode;
            const toggleButton = document.getElementById('manualDistanceToggle');
            const distanceField = document.getElementById('manualDistanceField');
            
            if (manualDistanceMode) {
                toggleButton.textContent = '📐 ปิดโหมดกำหนดระยะเอง';
                toggleButton.style.backgroundColor = '#ff6b6b';
                distanceField.style.display = 'block';
            } else {
                toggleButton.style.backgroundColor = '#4ecdc4';
                distanceField.style.display = 'none';
            }
            
            // อัปเดตการแสดงผลทันที
            updateInfo();
            if (points.length >= 2 && currentMode === 'height') {
                updateCalculationSteps();
            }
        }

        // อัปเดตระยะทางที่ผู้ใช้กำหนด
        function updateManualDistance(value) {
            manualDistance = parseFloat(value) || 5.0;
            
            // อัปเดตการแสดงผลทันที
            updateInfo();
            if (points.length >= 2 && currentMode === 'height') {
                updateCalculationSteps();
            }
        }
        
        // คำนวณความสูงด้วย Law of Cosines (เพิ่มฟังก์ชันที่หายไป)
        function calculateHeightFromLawOfCosines() {
            const angleC = parseFloat(document.getElementById('angleInput')?.value || '90');
            const sideA = parseFloat(document.getElementById('sideAInput')?.value || '3.0');
            const sideB = parseFloat(document.getElementById('sideBInput')?.value || '4.0');
            
            // ตรวจสอบค่าที่ป้อนเข้า
            if (isNaN(angleC) || isNaN(sideA) || isNaN(sideB)) {
                return 0;
            }
            
            // ตรวจสอบช่วงค่าที่ถูกต้อง
            if (angleC <= 0 || angleC >= 180 || sideA <= 0 || sideB <= 0) {
                return 0;
            }
            
            // แปลงมุมเป็นเรเดียน
            const angleCRad = (angleC * Math.PI) / 180;
            
            // คำนวณด้วย Law of Cosines: c² = a² + b² - 2ab cos(C)
            const cSquared = (sideA * sideA) + (sideB * sideB) - (2 * sideA * sideB * Math.cos(angleCRad));
            
            // ตรวจสอบว่าผลลัพธ์เป็นบวก (สามเหลี่ยมที่เป็นไปได้)
            if (cSquared < 0) {
                return 0; // ค่าที่ป้อนไม่สามารถสร้างสามเหลี่ยมได้
            }
            
            // คำนวณความสูง c
            const height = Math.sqrt(cSquared);
            
            // จำกัดค่าให้อยู่ในช่วงสมเหตุสมผล (0.01-1000 เมตร)
            const finalHeight = Math.max(0.01, Math.min(1000, height));
            
            // อัปเดตผลลัพธ์แบบเรียลไทม์
            updateResults(0, 0, finalHeight, 0);
            
            return finalHeight;
        }
    </script>
</body>
</html>
